<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Powergrid Flow Visualizer</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #05050d;
      color: #eee;
      font-family: sans-serif;
    }
    #container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    #glCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #uploadPanel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.75);
      padding: 8px 12px;
      border-radius: 4px;
      z-index: 10;
      font-size: 13px;
    }
    #uploadPanel input {
      font-size: 12px;
    }
    #status {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.75);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    #legend {
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;
      height: 60px;
      pointer-events: none;
      display: none; /* shown once data is ready */
      flex-direction: column;
      justify-content: flex-end;
      align-items: stretch;
    }
    #legendCanvas {
      width: 100%;
      height: 20px;
      border: 1px solid #aaa;
      border-radius: 3px;
      box-sizing: border-box;
    }
    #legendLabels {
      display: flex;
      justify-content: space-between;
      margin-top: 2px;
      font-size: 11px;
    }
  </style>
</head>
<body>
<div id="container">
  <canvas id="glCanvas"></canvas>

  <div id="uploadPanel">
    <div>Nodes CSV: <input type="file" id="nodesFile" accept=".csv" /></div>
    <div>Edges CSV: <input type="file" id="edgesFile" accept=".csv" /></div>
  </div>

  <div id="status">Load two CSV filesâ€¦</div>

  <div id="legend">
    <canvas id="legendCanvas" width="300" height="20"></canvas>
    <div id="legendLabels">
      <span id="legendMin">0</span>
      <span id="legendSplit">1000</span>
      <span id="legendMax">5000+</span>
    </div>
  </div>
</div>

<script>
  // ---- WebGL setup ----
  const canvas   = document.getElementById('glCanvas');
  const gl       = canvas.getContext('webgl2');
  const statusEl = document.getElementById('status');
  const uploadPanel = document.getElementById('uploadPanel');

  const legendEl        = document.getElementById('legend');
  const legendCanvas    = document.getElementById('legendCanvas');
  const legendCtx       = legendCanvas.getContext('2d');
  const legendMinLabel  = document.getElementById('legendMin');
  const legendSplitLabel= document.getElementById('legendSplit');
  const legendMaxLabel  = document.getElementById('legendMax');

  if (!gl) {
    alert('WebGL2 not supported');
  }

  function resizeCanvasOnly() {
    const displayWidth  = canvas.clientWidth;
    const displayHeight = canvas.clientHeight;
    if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
      canvas.width  = displayWidth;
      canvas.height = displayHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
  }

  function handleResize() {
    resizeCanvasOnly();
    if (nodeVertexCount > 0 || edgeVertexCount > 0) {
      drawScene();
    }
  }

  window.addEventListener('resize', handleResize);
  resizeCanvasOnly();

  // ---- Shader helpers ----
  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  function createProgram(gl, vsSource, fsSource) {
    const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(prog));
      gl.deleteProgram(prog);
      return null;
    }
    return prog;
  }

  // ---- Edge shaders (lines + piecewise heatmap color) ----
  const edgeVS = `#version 300 es
  in vec2  aPosition;   // already in clip-space [-1, 1] with aspect preserved
  in float aFlow;       // flow value
  out float vFlow;

  void main() {
    gl_Position = vec4(aPosition, 0.0, 1.0);
    vFlow = aFlow;
  }
  `;

  // Piecewise:
  // 0 .. split: blue -> yellow
  // split .. max: yellow -> red
  // > max: solid red
  const edgeFS = `#version 300 es
  precision highp float;

  in float vFlow;
  out vec4 outColor;

  uniform float uFlowMin;   // expected 0.0
  uniform float uFlowMax;   // capped, e.g. 5000
  uniform float uFlowSplit; // 1000

  void main() {
    float fMin   = uFlowMin;
    float fMax   = uFlowMax;
    float fSplit = uFlowSplit;

    // Guard against bad ranges
    if (fMax <= fMin) {
      outColor = vec4(1.0, 1.0, 1.0, 1.0);
      return;
    }
    fSplit = clamp(fSplit, fMin, fMax);

    // Clamp flow into [fMin, fMax]
    float f = clamp(vFlow, fMin, fMax);

    vec3 blue   = vec3(0.0, 0.0, 1.0);
    vec3 yellow = vec3(1.0, 1.0, 0.0);
    vec3 red    = vec3(1.0, 0.0, 0.0);
    vec3 color;

    if (f <= fSplit) {
      float denom = max(fSplit - fMin, 1e-6);
      float t = (f - fMin) / denom;   // 0..1
      color = mix(blue, yellow, t);
    } else {
      float denom = max(fMax - fSplit, 1e-6);
      float t = (f - fSplit) / denom; // 0..1
      color = mix(yellow, red, t);
    }

    outColor = vec4(color, 1.0);
  }
  `;

  const edgeProgram = createProgram(gl, edgeVS, edgeFS);
  const edgeAttribs = {
    aPosition: gl.getAttribLocation(edgeProgram, 'aPosition'),
    aFlow:     gl.getAttribLocation(edgeProgram, 'aFlow'),
  };
  const edgeUniforms = {
    uFlowMin:   gl.getUniformLocation(edgeProgram, 'uFlowMin'),
    uFlowMax:   gl.getUniformLocation(edgeProgram, 'uFlowMax'),
    uFlowSplit: gl.getUniformLocation(edgeProgram, 'uFlowSplit'),
  };

  const edgeVAO    = gl.createVertexArray();
  const edgeBuffer = gl.createBuffer();
  let edgeVertexCount = 0;

  // ---- Node shaders (small grey points) ----
  const nodeVS = `#version 300 es
  in vec2 aPosition;
  uniform float uPointSize;
  void main() {
    gl_Position = vec4(aPosition, 0.0, 1.0);
    gl_PointSize = uPointSize;
  }
  `;

  const nodeFS = `#version 300 es
  precision highp float;
  out vec4 outColor;
  void main() {
    vec2 coord = gl_PointCoord * 2.0 - 1.0;
    if (dot(coord, coord) > 1.0) {
      discard;
    }
    outColor = vec4(0.75, 0.75, 0.75, 1.0);
  }
  `;

  const nodeProgram = createProgram(gl, nodeVS, nodeFS);
  const nodeAttribs = {
    aPosition: gl.getAttribLocation(nodeProgram, 'aPosition'),
  };
  const nodeUniforms = {
    uPointSize: gl.getUniformLocation(nodeProgram, 'uPointSize'),
  };

  const nodeVAO    = gl.createVertexArray();
  const nodeBuffer = gl.createBuffer();
  let nodeVertexCount = 0;

  // ---- Data storage ----
  const busPos = new Map(); // busNumber -> {lon, lat}
  let lonMin = Infinity, lonMax = -Infinity;
  let latMin = Infinity, latMax = -Infinity;

  let edgesRaw = []; // {from, to, flow}

  // Flow range & split (heatmap control)
  const FLOW_MAX_CAP      = 5000.0;  // you said: cap at 5000
  const FLOW_SPLIT_TARGET = 1000.0;  // split at 1000

  let flowMin   = 0.0;
  let flowMax   = 1.0;
  let flowSplit = 1.0;

  // ---- CSV parsing ----
  function parseCSV(text) {
    const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
    if (lines.length === 0) return { headers: [], rows: [] };
    const header = lines[0].split(',').map(h => h.trim());
    const rows = lines.slice(1).map(line => {
      const cols = line.split(',').map(c => c.trim());
      const obj = {};
      header.forEach((h, i) => {
        obj[h] = cols[i];
      });
      return obj;
    });
    return { headers: header, rows };
  }

  // ---- File loading ----
  const nodesInput = document.getElementById('nodesFile');
  const edgesInput = document.getElementById('edgesFile');

  let nodesLoaded = false;
  let edgesLoaded = false;

  nodesInput.addEventListener('change', () => {
    const file = nodesInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      loadNodesCSV(reader.result);
      nodesLoaded = true;
      updateIfReady();
    };
    reader.readAsText(file);
  });

  edgesInput.addEventListener('change', () => {
    const file = edgesInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      loadEdgesCSV(reader.result);
      edgesLoaded = true;
      updateIfReady();
    };
    reader.readAsText(file);
  });

  function loadNodesCSV(text) {
    const { headers, rows } = parseCSV(text);
    function idx(name) {
      const lower = name.toLowerCase();
      return headers.findIndex(h => h.toLowerCase() === lower);
    }
    const busIdx = idx('Bus#');
    const lonIdx = idx('Longitude');
    const latIdx = idx('Latitude');

    if (busIdx === -1 || lonIdx === -1 || latIdx === -1) {
      alert('Nodes CSV must have columns: Bus#, Longitude, Latitude');
      return;
    }

    busPos.clear();
    lonMin = Infinity; lonMax = -Infinity;
    latMin = Infinity; latMax = -Infinity;

    for (const row of rows) {
      const cols = headers.map(h => row[h]);
      const busNumber = parseInt(cols[busIdx], 10);
      const lon = parseFloat(cols[lonIdx]);
      const lat = parseFloat(cols[latIdx]);
      if (!Number.isFinite(busNumber) || !Number.isFinite(lon) || !Number.isFinite(lat)) continue;

      busPos.set(busNumber, { lon, lat });
      lonMin = Math.min(lonMin, lon);
      lonMax = Math.max(lonMax, lon);
      latMin = Math.min(latMin, lat);
      latMax = Math.max(latMax, lat);
    }

    statusEl.textContent = `Loaded ${busPos.size} nodes`;
  }

  function loadEdgesCSV(text) {
    const { headers, rows } = parseCSV(text);
    function idx(name) {
      const lower = name.toLowerCase();
      return headers.findIndex(h => h.toLowerCase() === lower);
    }
    const fromIdx = idx('from');
    const toIdx   = idx('to');
    const flowIdx = idx('flow');

    if (fromIdx === -1 || toIdx === -1 || flowIdx === -1) {
      alert('Edges CSV must have columns: from, to, flow');
      return;
    }

    edgesRaw = [];
    for (const row of rows) {
      const cols    = headers.map(h => row[h]);
      const fromBus = parseInt(cols[fromIdx], 10);
      const toBus   = parseInt(cols[toIdx], 10);
      const flow    = parseFloat(cols[flowIdx]);
      if (!Number.isFinite(fromBus) || !Number.isFinite(toBus) || !Number.isFinite(flow)) continue;
      edgesRaw.push({ from: fromBus, to: toBus, flow });
    }
    statusEl.textContent = `Loaded ${edgesRaw.length} edges`;
  }

  // ---- Coordinate mapping: (lon, lat) -> clip-space (x, y) in [-1, 1] without stretching ----
  function lonLatToClip(lon, lat) {
    const width  = lonMax - lonMin;
    const height = latMax - latMin;

    if (width === 0 || height === 0) {
      return [0.0, 0.0];
    }

    const centerLon = (lonMax + lonMin) * 0.5;
    const centerLat = (latMax + latMin) * 0.5;

    const maxSpan = Math.max(width, height);
    const scale   = 2.0 / maxSpan; // ensures larger dimension fits [-1,1]

    const x = (lon - centerLon) * scale;
    const y = (lat - centerLat) * scale;

    // x,y are already within [-1,1] in the bigger dimension; smaller dimension <1, so aspect preserved
    return [x, y];
  }

  // ---- Build GPU buffers when both CSVs are loaded ----
  function updateIfReady() {
    if (!nodesLoaded || !edgesLoaded) return;
    if (busPos.size === 0 || edgesRaw.length === 0) return;

    // Hide uploader once data is ready
    if (uploadPanel) {
      uploadPanel.style.display = 'none';
    }

    // Build node positions
    const nodePositions = [];
    for (const [bus, { lon, lat }] of busPos.entries()) {
      const [x, y] = lonLatToClip(lon, lat);
      nodePositions.push(x, y);
    }
    nodeVertexCount = nodePositions.length / 2;

    gl.bindVertexArray(nodeVAO);
    gl.bindBuffer(gl.ARRAY_BUFFER, nodeBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nodePositions), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(nodeAttribs.aPosition);
    gl.vertexAttribPointer(nodeAttribs.aPosition, 2, gl.FLOAT, false, 0, 0);
    gl.bindVertexArray(null);

    // Build edges: for each edge, two vertices (from, to) with same flow
    const edgeData = []; // [x, y, flow, x, y, flow, ...]
    let localFlowMin = Infinity;
    let localFlowMax = -Infinity;
    let skipped = 0;

    //Marker comment

    for (const e of edgesRaw) {
      /*if (e.flow < 70) 
      {
        skipped++;
        continue;

      };*/

      const fromPos = busPos.get(e.from);
      const toPos   = busPos.get(e.to);
      if (!fromPos || !toPos) {
        skipped++;
        continue;
      }
      const [x1, y1] = lonLatToClip(fromPos.lon, fromPos.lat);
      const [x2, y2] = lonLatToClip(toPos.lon, toPos.lat);
      edgeData.push(x1, y1, e.flow, x2, y2, e.flow);
      localFlowMin = Math.min(localFlowMin, e.flow);
      localFlowMax = Math.max(localFlowMax, e.flow);
    }

    // Heatmap control:
    // assume flows >= 0 are interesting; clamp to [0, FLOW_MAX_CAP]
    if (!Number.isFinite(localFlowMin) || !Number.isFinite(localFlowMax)) {
      flowMin = 0.0;
      flowMax = 1.0;
      flowSplit = 0.5;
    } else {
      flowMin   = 0.0; // treat anything below 0 as 0
      const cappedMax = Math.min(localFlowMax, FLOW_MAX_CAP);
      flowMax   = cappedMax > flowMin ? cappedMax : flowMin + 1.0;
      flowSplit = Math.min(FLOW_SPLIT_TARGET, flowMax);
    }

    edgeVertexCount = edgeData.length / 3;

    gl.bindVertexArray(edgeVAO);
    gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(edgeData), gl.STATIC_DRAW);

    const stride = 3 * 4; // 3 floats * 4 bytes
    gl.enableVertexAttribArray(edgeAttribs.aPosition);
    gl.vertexAttribPointer(edgeAttribs.aPosition, 2, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(edgeAttribs.aFlow);
    gl.vertexAttribPointer(edgeAttribs.aFlow, 1, gl.FLOAT, false, stride, 2 * 4);
    gl.bindVertexArray(null);

    statusEl.textContent =
      `Ready: ${busPos.size} nodes, ${edgesRaw.length} edges (${skipped} skipped), flow in [${flowMin.toFixed(1)}, ${flowMax.toFixed(1)}], split @ ${flowSplit.toFixed(1)}`;

    // Show and draw legend
    if (legendEl) {
      legendEl.style.display = 'flex';
      legendMinLabel.textContent   = flowMin.toFixed(0);
      legendSplitLabel.textContent = flowSplit.toFixed(0);
      legendMaxLabel.textContent   = (flowMax >= FLOW_MAX_CAP - 1.0)
        ? FLOW_MAX_CAP.toFixed(0) + '+'
        : flowMax.toFixed(0);
      drawLegend();
    }

    resizeCanvasOnly();
    drawScene();
  }

  function drawLegend() {
    if (!legendCtx) return;
    const w = legendCanvas.width;
    const h = legendCanvas.height;

    legendCtx.clearRect(0, 0, w, h);

    // Gradient consistent with shader:
    // left = blue (0), middle at split = yellow, right = red (max)
    const grad = legendCtx.createLinearGradient(0, 0, w, 0);

    const min = flowMin;
    const max = flowMax;
    const split = flowSplit;
    const range = Math.max(max - min, 1e-6);
    const midT  = (split - min) / range; // position of yellow

    grad.addColorStop(0.0,  'rgb(0,0,255)');       // blue
    grad.addColorStop(midT, 'rgb(255,255,0)');     // yellow
    grad.addColorStop(1.0,  'rgb(255,0,0)');       // red

    legendCtx.fillStyle = grad;
    legendCtx.fillRect(0, 0, w, h);
  }

  // ---- Draw ----
  function drawScene() {
    gl.clearColor(0.05, 0.05, 0.08, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Draw edges
    gl.useProgram(edgeProgram);
    gl.bindVertexArray(edgeVAO);
    gl.uniform1f(edgeUniforms.uFlowMin,   flowMin);
    gl.uniform1f(edgeUniforms.uFlowMax,   flowMax);
    gl.uniform1f(edgeUniforms.uFlowSplit, flowSplit);
    gl.lineWidth(1.0); // >1 is not guaranteed
    gl.drawArrays(gl.LINES, 0, edgeVertexCount);
    gl.bindVertexArray(null);

    // Draw nodes
    gl.useProgram(nodeProgram);
    gl.bindVertexArray(nodeVAO);
    const pointSize = 2.0;
    gl.uniform1f(nodeUniforms.uPointSize, pointSize);
    gl.drawArrays(gl.POINTS, 0, nodeVertexCount);
    gl.bindVertexArray(null);
  }
</script>
</body>
</html>
